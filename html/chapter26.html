<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第26章：案例解析：《哈姆雷特》的悲剧算法</title>
    <link rel="stylesheet" href="./assets/style.css">
    <link rel="stylesheet" href="./assets/highlight.css">
    <script src="./assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <ul class="nav-list"><li class=""><a href="./index.html">讲好故事的艺术：从神话到科技论文</a></li><li class=""><a href="./chapter1.html">第1章：故事的原子结构——最小叙事单元与组合模式</a></li><li class=""><a href="./chapter2.html">第2章：英雄之旅的函数式编程——坎贝尔单一神话的模块化</a></li><li class=""><a href="./chapter3.html">第3章：五幕结构的标准协议——从古希腊到好莱坞的接口设计</a></li><li class=""><a href="./chapter4.html">第4章：三幕与起承转合——东西方叙事框架的同构映射</a></li><li class=""><a href="./chapter5.html">第5章：冲突引擎的设计模式——内外冲突的分类与升级机制</a></li><li class=""><a href="./chapter6.html">第6章：案例解析：《星际穿越》的叙事架构逆向工程</a></li><li class=""><a href="./chapter7.html">第7章：角色的类与实例——原型理论与个性化参数</a></li><li class=""><a href="./chapter8.html">第8章：人物弧的状态机——从静态到动态的角色成长系统</a></li><li class=""><a href="./chapter9.html">第9章：世界观的分层架构——设定、规则与内在逻辑的一致性</a></li><li class=""><a href="./chapter10.html">第10章：魔法系统的API设计——硬魔法与软魔法的接口定义</a></li><li class=""><a href="./chapter11.html">第11章：时空框架的坐标系——线性、循环与平行叙事的实现</a></li><li class=""><a href="./chapter12.html">第12章：案例解析：《哈利·波特》的世界观工程</a></li><li class=""><a href="./chapter13.html">第13章：案例解析：《红楼梦》的多层世界观架构</a></li><li class=""><a href="./chapter14.html">第14章：悬念的队列管理——问题的提出、延迟与解答</a></li><li class=""><a href="./chapter15.html">第15章：伏笔的异步编程——回调、承诺与最终兑现</a></li><li class=""><a href="./chapter16.html">第16章：节奏的时钟周期——张弛、快慢与情绪曲线</a></li><li class=""><a href="./chapter17.html">第17章：信息密度的带宽控制——展示vs叙述的动态平衡</a></li><li class=""><a href="./chapter18.html">第18章：视角的多线程处理——全知、限制与不可靠叙述者</a></li><li class=""><a href="./chapter19.html">第19章：案例解析：《罗生门》的信息控制艺术</a></li><li class=""><a href="./chapter20.html">第20章：故事审美的不变量与变量——人类叙事偏好的历史演化</a></li><li class=""><a href="./chapter21.html">第21章：神话模式的递归结构——从洪水神话到创世神话的模板</a></li><li class=""><a href="./chapter22.html">第22章：悲剧的异常处理——亚里士多德的净化机制</a></li><li class=""><a href="./chapter23.html">第23章：喜剧的bug利用——误会、巧合与荒诞的逻辑</a></li><li class=""><a href="./chapter24.html">第24章：侦探小说的回溯算法——线索、推理与真相还原</a></li><li class=""><a href="./chapter25.html">第25章：成长故事的升级系统——从零到英雄的经验值累积</a></li><li class="active"><a href="./chapter26.html">第26章：案例解析：《哈姆雷特》的悲剧算法</a></li><li class=""><a href="./chapter27.html">第27章：案例解析：《西游记》的升级系统与团队副本设计</a></li><li class=""><a href="./chapter28.html">第28章：文字的想象空间——描写的分辨率与留白的艺术</a></li><li class=""><a href="./chapter29.html">第29章：影视的镜头语言——蒙太奇、场面调度与视听节奏</a></li><li class=""><a href="./chapter30.html">第30章：游戏的交互叙事——玩家代理与emergent narrative</a></li><li class=""><a href="./chapter31.html">第31章：漫画的时空压缩——分格、留白与阅读节奏控制</a></li><li class=""><a href="./chapter32.html">第32章：音频的盲盒体验——播客、有声书与纯听觉叙事</a></li><li class=""><a href="./chapter33.html">第33章：案例解析：《原神》的开放世界叙事</a></li><li class=""><a href="./chapter34.html">第34章：连载的版本迭代——网文的敏捷开发与用户反馈循环</a></li><li class=""><a href="./chapter35.html">第35章：短视频的极限压缩——钩子、爆点与15秒完整弧</a></li><li class=""><a href="./chapter36.html">第36章：直播的实时渲染——即兴叙事与弹幕交互</a></li><li class=""><a href="./chapter37.html">第37章：社交媒体的分布式叙事——碎片化内容的聚合与重组</a></li><li class=""><a href="./chapter38.html">第38章：算法推荐下的叙事优化——留存率、完播率与情绪曲线</a></li><li class=""><a href="./chapter39.html">第39章：案例解析：《射雕英雄传》的连载叙事艺术</a></li><li class=""><a href="./chapter40.html">第40章：科技论文的叙事重构——问题、方法、发现的戏剧化</a></li><li class=""><a href="./chapter41.html">第41章：数据可视化的故事设计——让图表说话的技巧</a></li><li class=""><a href="./chapter42.html">第42章：故事与人工智能：新的可能性</a></li><li class=""><a href="./chapter43.html">第43章：技术演讲的舞台表演——TED式叙事与学术报告的平衡</a></li><li class=""><a href="./chapter44.html">第44章：案例研究的纪录片手法——真实故事的戏剧化处理</a></li><li class=""><a href="./chapter45.html">第45章：案例解析：AlphaGo论文的叙事策略</a></li><li class=""><a href="./chapter46.html">第46章：元叙事的递归调用——故事中的故事与自指结构</a></li><li class=""><a href="./chapter47.html">第47章：非线性叙事的图算法——多线索、多结局与时间循环</a></li><li class=""><a href="./chapter48.html">第48章：跨媒介叙事的适配器模式——IP的多平台展开</a></li><li class=""><a href="./chapter49.html">第49章：AI辅助创作的协处理器——提示工程与人机协作</a></li><li class=""><a href="./chapter50.html">第50章：元宇宙叙事的新维度——沉浸、互动与生成式故事</a></li><li class=""><a href="./chapter51.html">第51章：案例解析：《底特律：变人》的交互叙事实验</a></li><li class=""><a href="./chapter52.html">第52章：叙事模式库——50个可复用的故事模板</a></li><li class=""><a href="./chapter53.html">第53章：检查清单大全——各类型作品的审查要点</a></li><li class=""><a href="./chapter54.html">第54章：常见bug与调试——叙事问题的诊断与修复</a></li><li class=""><a href="./chapter55.html">第55章：跨文化移植指南——故事的本地化与全球化</a></li><li class=""><a href="./chapter56.html">第56章：叙事度量与评估——故事质量的量化分析</a></li><li class=""><a href="./chapter57.html">第57章：诊断实践：《三体》第三部的叙事问题修复</a></li><li class=""><a href="./CLAUDE.html">Untitled</a></li></ul>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="26">第26章：案例解析：《哈姆雷特》的悲剧算法</h1>
<p>莎士比亚的《哈姆雷特》不仅是西方文学史上最伟大的悲剧之一，更是一个关于系统性失败的精密算法。如果我们用程序员的视角审视这部作品，会发现它本质上是一个充满死锁、递归陷阱和级联崩溃的复杂系统。每个角色都像运行在不同线程上的进程，他们的交互产生了竞争条件、资源争夺和最终的系统崩溃。本章将用系统分析的方法，解构这个四百年前的"程序"如何通过精妙的bug设计，创造出永恒的悲剧效果。</p>
<h2 id="261">26.1 延宕的死锁问题：行动与思考的矛盾</h2>
<h3 id="2611">26.1.1 哈姆雷特的内部死锁</h3>
<p>哈姆雷特的核心困境可以用并发编程中的死锁来理解。他需要两个"资源"才能执行复仇：</p>
<ol>
<li><strong>确定性证据</strong>（父亲鬼魂的话是否可信）</li>
<li><strong>道德正当性</strong>（杀死叔父是否正义）</li>
</ol>
<p>但这两个资源形成了循环等待：</p>
<ul>
<li>要获得道德正当性，需要先确认克劳狄斯的罪行</li>
<li>要确认罪行，需要采取行动（如戏中戏）</li>
<li>要采取行动，又需要先克服道德疑虑</li>
</ul>
<div class="codehilite"><pre><span></span><code>Thread Hamlet {
    lock(moralJustification);  // 等待道德确认
    lock(evidence);             // 等待证据
    execute(revenge);
}

Thread Conscience {
    lock(evidence);             // 需要证据才能给予道德许可
    lock(moralJustification);   // 给予道德许可
}
// 死锁产生：两个线程互相等待对方释放资源
</code></pre></div>

<h3 id="2612-to-be-or-not-to-be">26.1.2 "To be or not to be"的二进制选择</h3>
<p>著名独白"To be or not to be"实际上是一个关于进程终止的哲学思考：</p>
<div class="codehilite"><pre><span></span><code>while (true) {
    if (shouldTerminate()) {
        // &quot;To die, to sleep&quot;
        exit(0);
    } else {
        // &quot;To suffer the slings and arrows&quot;
        continue;
    }
    // 决策延迟导致无限循环
    sleep(THINKING_TIME);
}
</code></pre></div>

<p>这个循环永远无法跳出，因为哈姆雷特无法解决根本的决策条件：生命的意义评估函数<code>shouldTerminate()</code>始终返回不确定值。</p>
<h3 id="2613">26.1.3 延宕的性能损失</h3>
<p>哈姆雷特的延宕在系统层面造成了严重的性能损失：</p>
<ul>
<li><strong>CPU空转</strong>：大量思考却无实际输出</li>
<li><strong>内存泄漏</strong>：情感和怨恨不断累积，无法释放</li>
<li><strong>响应延迟</strong>：外部事件（如波洛涅斯之死）得不到及时处理</li>
</ul>
<p>每次延宕都会触发新的事件链，增加系统复杂度，最终导致不可控的连锁反应。</p>
<h2 id="262">26.2 复仇的递归陷阱：暴力的循环调用</h2>
<h3 id="2621">26.2.1 复仇链的递归结构</h3>
<p>《哈姆雷特》中的复仇形成了多层递归调用：</p>
<div class="codehilite"><pre><span></span><code><span class="nv">function</span><span class="w"> </span><span class="nv">revenge</span><span class="ss">(</span><span class="nv">victim</span>,<span class="w"> </span><span class="nv">killer</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">killer</span>.<span class="nv">isDead</span><span class="ss">())</span><span class="w"> </span><span class="k">return</span><span class="c1">;</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span>基础情况：老哈姆雷特被克劳狄斯杀死
<span class="w">    </span><span class="o">//</span><span class="w"> </span>递归调用<span class="mi">1</span>：哈姆雷特要为父亲复仇
<span class="w">    </span><span class="o">//</span><span class="w"> </span>递归调用<span class="mi">2</span>：雷欧提斯要为父亲波洛涅斯复仇
<span class="w">    </span><span class="o">//</span><span class="w"> </span>递归调用<span class="mi">3</span>：福丁布拉斯为父亲征服失地

<span class="w">    </span><span class="nv">newKiller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">victim</span>.<span class="nv">child</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">newKiller</span>.<span class="nv">seekRevenge</span><span class="ss">(</span><span class="nv">killer</span><span class="ss">)</span><span class="c1">;</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span>危险：没有终止条件的递归
<span class="w">    </span><span class="nv">revenge</span><span class="ss">(</span><span class="nv">killer</span>,<span class="w"> </span><span class="nv">newKiller</span><span class="ss">)</span><span class="c1">;</span>
}
</code></pre></div>

<h3 id="2622">26.2.2 栈溢出的必然性</h3>
<p>这种无限递归最终导致"栈溢出"——所有主要角色死亡：</p>
<ol>
<li>克劳狄斯杀死老哈姆雷特（初始调用）</li>
<li>哈姆雷特误杀波洛涅斯（栈深度+1）</li>
<li>雷欧提斯与哈姆雷特决斗（栈深度+2）</li>
<li>格特鲁德误饮毒酒（副作用）</li>
<li>哈姆雷特杀死克劳狄斯（栈深度+3）</li>
<li>所有人死亡（栈溢出）</li>
</ol>
<h3 id="2623">26.2.3 福丁布拉斯：垃圾回收器</h3>
<p>挪威王子福丁布拉斯的出现类似于垃圾回收器（GC）：</p>
<ul>
<li>在系统崩溃后介入</li>
<li>清理"内存"（死尸遍地的宫廷）</li>
<li>重新分配"资源"（王位继承）</li>
<li>恢复系统秩序</li>
</ul>
<p>他的成功恰恰因为他不在递归调用链中，能够以外部观察者的身份终止这个失控的程序。</p>
<h2 id="263">26.3 疯狂的状态伪装：真疯与装疯的界面设计</h2>
<h3 id="2631">26.3.1 状态模式的实现</h3>
<p>哈姆雷特的疯狂可以理解为一个精心设计的状态模式：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">interface</span><span class="w"> </span><span class="nx">MadnessState</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">void</span><span class="w"> </span><span class="nx">speak</span><span class="p">();</span>
<span class="w">    </span><span class="nx">void</span><span class="w"> </span><span class="nx">act</span><span class="p">();</span>
<span class="w">    </span><span class="nx">boolean</span><span class="w"> </span><span class="nx">isGenuine</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nx">FeignedMadness</span><span class="w"> </span><span class="nx">implements</span><span class="w"> </span><span class="nx">MadnessState</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">void</span><span class="w"> </span><span class="nx">speak</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 有逻辑的胡言乱语</span>
<span class="w">        </span><span class="nx">output</span><span class="p">(</span><span class="nx">encodeMessage</span><span class="p">(</span><span class="nx">truth</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">void</span><span class="w"> </span><span class="nx">act</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 有目的的失常行为</span>
<span class="w">        </span><span class="nx">performCalculatedChaos</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">boolean</span><span class="w"> </span><span class="nx">isGenuine</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nx">GenuineMadness</span><span class="w"> </span><span class="nx">implements</span><span class="w"> </span><span class="nx">MadnessState</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">void</span><span class="w"> </span><span class="nx">speak</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 真正的精神错乱</span>
<span class="w">        </span><span class="nx">output</span><span class="p">(</span><span class="nx">random</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">void</span><span class="w"> </span><span class="nx">act</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 失控的行为</span>
<span class="w">        </span><span class="nx">performUncontrolledActions</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">boolean</span><span class="w"> </span><span class="nx">isGenuine</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="2632">26.3.2 奥菲利亚的状态转换</h3>
<p>奥菲利亚展示了从装疯到真疯的状态转换：</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="n">Ophelia</span> {
    <span class="n">MadnessState</span> <span class="k">state</span> = <span class="nb">new</span> <span class="n">Normal</span>();

    <span class="n">void</span> <span class="n">onFatherDeath</span>() {
        // <span class="n">触发状态转换</span>
        <span class="k">state</span> = <span class="nb">new</span> <span class="n">GenuineMadness</span>();

        // <span class="n">状态不可逆</span>
        <span class="k">while</span> (<span class="n">true</span>) {
            <span class="n">singFragmentedSongs</span>();
            <span class="n">distributeFlowers</span>();
            <span class="k">if</span> (<span class="n">nearWater</span>()) {
                <span class="n">terminate</span>();  // <span class="n">溺水</span>
            }
        }
    }
}
</code></pre></div>

<h3 id="2633">26.3.3 疯狂作为调试模式</h3>
<p>哈姆雷特的装疯实际上是一种"调试模式"：</p>
<ul>
<li><strong>日志输出增强</strong>：说出平时不能说的真话</li>
<li><strong>权限提升</strong>：可以做出越轨行为而不受惩罚</li>
<li><strong>观察者模式</strong>：其他人物对他的反应暴露真实意图</li>
</ul>
<p>这种伪装让他能够在不触发系统防御机制的情况下，探测其他角色的内部状态。</p>
<h2 id="264">26.4 戏中戏的单元测试：验证假设的元戏剧</h2>
<h3 id="2641">26.4.1 测试用例的设计</h3>
<p>"捕鼠器"戏剧是哈姆雷特设计的一个精妙的单元测试：</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="n">MurderTest</span> {
    // <span class="n">测试目标</span>：<span class="n">验证克劳狄斯是否杀害了老王</span>

    <span class="n">void</span> <span class="n">setup</span>() {
        // <span class="n">准备测试环境</span>
        <span class="n">stage</span> = <span class="n">prepareTheater</span>();
        <span class="n">actors</span> = <span class="n">hireActors</span>();
        <span class="n">audience</span> = <span class="n">inviteCourtiers</span>();
    }

    <span class="n">boolean</span> <span class="n">test</span>() {
        // <span class="n">执行测试</span>
        <span class="n">play</span>(<span class="s">&quot;The Murder of Gonzago&quot;</span>);

        // <span class="n">断言</span>
        <span class="k">return</span> <span class="n">claudius</span>.<span class="n">reaction</span> == <span class="n">GUILTY</span>;
    }

    <span class="n">void</span> <span class="n">teardown</span>() {
        // <span class="n">清理</span>
        <span class="n">dismissActors</span>();
    }
}
</code></pre></div>

<h3 id="2642">26.4.2 观察者的监控</h3>
<p>哈姆雷特和霍雷肖作为观察者，监控测试结果：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">class</span><span class="w"> </span><span class="nx">TestObserver</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">void</span><span class="w"> </span><span class="k">observe</span><span class="p">(</span><span class="nx">King</span><span class="w"> </span><span class="nx">claudius</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">play</span><span class="p">.</span><span class="nx">isRunning</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">claudius</span><span class="p">.</span><span class="nx">showsGuilt</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">log</span><span class="p">(</span><span class="s">&quot;Test passed: King is guilty&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="2643">26.4.3 测试的副作用</h3>
<p>这个"单元测试"产生了意想不到的副作用：</p>
<ul>
<li><strong>暴露意图</strong>：克劳狄斯知道哈姆雷特已经知道真相</li>
<li><strong>触发防御</strong>：克劳狄斯开始主动策划除掉哈姆雷特</li>
<li><strong>系统不稳定</strong>：打破了原有的假装和平</li>
</ul>
<p>这说明在生产环境中运行测试的危险性——测试本身改变了系统状态。</p>
<h2 id="265">26.5 悲剧的级联崩溃：多米诺式的毁灭</h2>
<h3 id="2651">26.5.1 级联失败的触发</h3>
<p>一个小错误（误杀波洛涅斯）触发了整个系统的级联崩溃：</p>
<div class="codehilite"><pre><span></span><code>Event chain:

1. Hamlet.kill(Polonius)        // 误杀
   → Ophelia.setState(MAD)      // 女儿发疯
   → Ophelia.drown()            // 自杀
   → Laertes.seekRevenge()      // 儿子复仇

2. Claudius.plot(poisonedSword) // 密谋
   → Duel.initialize()          // 决斗
   → Gertrude.drink(poison)     // 误饮
   → Laertes.wound(Hamlet)      // 互伤
   → Hamlet.wound(Laertes)      

3. System.collapse()            // 全面崩溃
   → Hamlet.kill(Claudius)      
   → Hamlet.die()
   → Laertes.die()
   → Fortinbras.inherit()       // 系统重启
</code></pre></div>

<h3 id="2652">26.5.2 错误处理的缺失</h3>
<p>悲剧的根源在于缺乏错误处理机制：</p>
<div class="codehilite"><pre><span></span><code>try {
    hamlet.executeRevenge();
} catch (MoralDilemma e) {
    // 没有catch块：道德困境无法处理
} catch (CollateralDamage e) {
    // 没有catch块：附带伤害无法避免
} finally {
    // 没有finally块：无法保证资源清理
    // 结果：所有人死亡
}
</code></pre></div>

<h3 id="2653">26.5.3 系统的脆弱性分析</h3>
<p>丹麦宫廷作为一个系统，存在致命的设计缺陷：</p>
<ul>
<li><strong>单点故障</strong>：国王的合法性问题影响整个系统</li>
<li><strong>缺乏冗余</strong>：没有备份计划或替代方案</li>
<li><strong>紧耦合</strong>：角色间关系过于紧密，一个崩溃全部崩溃</li>
<li><strong>缺乏隔离</strong>：个人恩怨与国家治理没有分离</li>
</ul>
<h2 id="_1">本章小结</h2>
<p>《哈姆雷特》的悲剧性在于其精确的"算法设计"：</p>
<ol>
<li><strong>死锁机制</strong>：思考与行动的相互阻塞创造了悲剧的核心张力</li>
<li><strong>递归陷阱</strong>：复仇的无限循环确保了毁灭的必然性</li>
<li><strong>状态伪装</strong>：真假难辨的疯狂增加了系统的不确定性</li>
<li><strong>测试悲剧</strong>：验证真相的尝试反而加速了崩溃</li>
<li><strong>级联失败</strong>：错误的连锁反应导致全面系统崩溃</li>
</ol>
<p>莎士比亚通过这些"程序设计"，创造了一个必然走向毁灭的系统。每个角色都在执行自己的"代码"，但他们的交互产生了无法预料的涌现性——这正是悲剧的本质。作为现代的故事设计者，我们可以学习如何构建这样的"必然性系统"，让结局既出人意料又在情理之中。</p>
<h2 id="_2">练习题</h2>
<h3 id="_3">基础题</h3>
<p><strong>练习26.1：死锁识别</strong>
在《罗密欧与朱丽叶》中，两个家族的世仇创造了另一种死锁。请分析：</p>
<ul>
<li>罗密欧需要什么"资源"才能与朱丽叶在一起？</li>
<li>这些资源如何形成循环等待？</li>
<li>与《哈姆雷特》的死锁有何异同？</li>
</ul>
<p><em>提示：考虑家族认可、社会接受、个人安全等"资源"</em></p>
<details>
<summary>参考答案</summary>
<p>罗密欧与朱丽叶的死锁结构：</p>
<ol>
<li>
<p><strong>需要的资源</strong>：
   - 家族和解（两家停止世仇）
   - 公开身份（不再需要隐瞒）
   - 安全保障（不会被追杀）</p>
</li>
<li>
<p><strong>循环等待</strong>：
   - 要获得家族和解，需要先证明爱情的力量
   - 要证明爱情，需要公开关系
   - 要公开关系，需要安全保障
   - 要获得安全，需要家族和解</p>
</li>
<li>
<p><strong>与哈姆雷特的对比</strong>：
   - 哈姆雷特：内部死锁（思想vs行动）
   - 罗朱：外部死锁（个人vs社会）
   - 哈姆雷特：可以通过个人决断打破
   - 罗朱：需要外部条件改变</p>
</li>
</ol>
<p>两者都通过死亡来"解决"死锁，但机制不同：哈姆雷特是系统崩溃，罗朱是用极端代价换取资源释放。</p>
</details>
<p><strong>练习26.2：递归深度计算</strong>
《俄狄浦斯王》中也存在复仇递归。请画出从拉伊俄斯（俄狄浦斯之父）开始的复仇调用栈，并分析其终止条件。</p>
<p><em>提示：考虑神谕、命运和自我惩罚</em></p>
<details>
<summary>参考答案</summary>
<p>递归调用栈：</p>
<div class="codehilite"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">拉伊俄斯抛弃俄狄浦斯</span><span class="err">（</span><span class="n">试图避免神谕</span><span class="err">）</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">俄狄浦斯杀死拉伊俄斯</span><span class="err">（</span><span class="n">不知是父亲</span><span class="err">）</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">神明降下瘟疫</span><span class="err">（</span><span class="n">惩罚弑父</span><span class="err">）</span>
<span class="mf">4.</span><span class="w"> </span><span class="n">俄狄浦斯自我流放</span><span class="err">（</span><span class="n">自我惩罚</span><span class="err">）</span>
<span class="mf">5.</span><span class="w"> </span><span class="n">子女受诅咒</span><span class="err">（</span><span class="n">安提戈涅等人的悲剧</span><span class="err">）</span>
</code></pre></div>

<p>终止条件：</p>
<ul>
<li>俄狄浦斯的自我惩罚（刺瞎双眼）部分终止了循环</li>
<li>但诅咒延续到下一代</li>
<li>真正的终止：安提戈涅之死，家族绝嗣</li>
</ul>
<p>这比哈姆雷特更残酷：递归跨越了代际，需要整个家族的毁灭才能终止。</p>
</details>
<p><strong>练习26.3：状态机设计</strong>
设计李尔王的精神状态机，包括：理智、愤怒、疯狂、清醒等状态，以及触发状态转换的事件。</p>
<p><em>提示：考虑每个状态的不可逆性</em></p>
<details>
<summary>参考答案</summary>
<div class="codehilite"><pre><span></span><code><span class="err">状态机设计：</span>

<span class="n">States</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="err">理智</span><span class="p">,</span><span class="w"> </span><span class="err">愤怒</span><span class="p">,</span><span class="w"> </span><span class="err">妄想</span><span class="p">,</span><span class="w"> </span><span class="err">疯狂</span><span class="p">,</span><span class="w"> </span><span class="err">清醒</span><span class="p">}</span>

<span class="n">Transitions</span><span class="o">:</span>
<span class="err">理智</span><span class="w"> </span><span class="o">--</span><span class="p">[</span><span class="err">女儿奉承</span><span class="p">]</span><span class="o">--&gt;</span><span class="w"> </span><span class="err">妄想</span>
<span class="err">妄想</span><span class="w"> </span><span class="o">--</span><span class="p">[</span><span class="err">分割王国</span><span class="p">]</span><span class="o">--&gt;</span><span class="w"> </span><span class="err">愤怒</span>
<span class="err">愤怒</span><span class="w"> </span><span class="o">--</span><span class="p">[</span><span class="err">被拒绝</span><span class="p">]</span><span class="o">--&gt;</span><span class="w"> </span><span class="err">疯狂</span>
<span class="err">疯狂</span><span class="w"> </span><span class="o">--</span><span class="p">[</span><span class="err">暴风雨</span><span class="p">]</span><span class="o">--&gt;</span><span class="w"> </span><span class="err">疯狂（自循环）</span>
<span class="err">疯狂</span><span class="w"> </span><span class="o">--</span><span class="p">[</span><span class="err">寇蒂莉亚归来</span><span class="p">]</span><span class="o">--&gt;</span><span class="w"> </span><span class="err">清醒</span>
<span class="err">清醒</span><span class="w"> </span><span class="o">--</span><span class="p">[</span><span class="err">寇蒂莉亚死</span><span class="p">]</span><span class="o">--&gt;</span><span class="w"> </span><span class="err">死亡</span>

<span class="err">特点：</span>

<span class="mf">1.</span><span class="w"> </span><span class="err">单向转换：无法回到</span><span class="s">&quot;理智&quot;</span><span class="err">状态</span>
<span class="mf">2.</span><span class="w"> </span><span class="err">疯狂的自循环：在暴风雨中的长时间疯狂</span>
<span class="mf">3.</span><span class="w"> </span><span class="err">短暂清醒：只在最后时刻</span>
<span class="mf">4.</span><span class="w"> </span><span class="err">悲剧性：清醒后立即死亡</span>
</code></pre></div>

</details>
<h3 id="_4">挑战题</h3>
<p><strong>练习26.4：测试策略优化</strong>
如果你是哈姆雷特，如何设计一个更好的"单元测试"来验证克劳狄斯的罪行，同时避免暴露自己的意图？</p>
<p><em>提示：考虑A/B测试、控制变量、假阳性等概念</em></p>
<details>
<summary>参考答案</summary>
<p>优化的测试策略：</p>
<ol>
<li>
<p><strong>A/B测试设计</strong>：
   - A组：演出多个剧目，包括无关主题
   - B组：逐渐接近真相的剧目
   - 观察克劳狄斯对不同剧目的反应差异</p>
</li>
<li>
<p><strong>控制变量</strong>：
   - 使用代理人提议演出（避免直接关联）
   - 在多个场合测试（降低单次测试的重要性）
   - 引入噪音（其他人也表现出类似兴趣）</p>
</li>
<li>
<p><strong>降低假阳性</strong>：
   - 设置多个检查点
   - 交叉验证（通过其他渠道确认）
   - 延长观察期（避免急于下结论）</p>
</li>
<li>
<p><strong>隐藏意图</strong>：
   - 表现出对多个主题的兴趣
   - 使用"教育"或"娱乐"作为借口
   - 让别人提出看戏的建议</p>
</li>
</ol>
<p>这种方法虽然更慢，但更安全，可能避免悲剧的级联崩溃。</p>
</details>
<p><strong>练习26.5：并发控制设计</strong>
设计一个"线程安全"版本的《哈姆雷特》，使用锁、信号量或其他并发控制机制来避免悲剧的发生。</p>
<p><em>提示：考虑如何协调不同角色的行动</em></p>
<details>
<summary>参考答案</summary>
<p>线程安全版本设计：</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">SafeHamlet</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">revengeLock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">truthSemaphore</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">seekRevenge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">revengeLock</span><span class="p">:</span>
            <span class="c1"># 获取锁后才能复仇</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verifyTruth</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">executeJustice</span><span class="p">()</span>
            <span class="c1"># 自动释放锁</span>

    <span class="k">def</span> <span class="nf">verifyTruth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">truthSemaphore</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="c1"># 一次只允许一个真相验证</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">investigate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">truthSemaphore</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">communicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="c1"># 使用消息队列避免直接冲突</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">processActions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionQueue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionQueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="c1"># 顺序处理，避免并发冲突</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handleAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
</code></pre></div>

<p>关键改进：</p>
<ol>
<li>互斥锁防止复仇冲突</li>
<li>信号量控制真相验证</li>
<li>消息队列避免直接对抗</li>
<li>顺序处理降低意外</li>
</ol>
</details>
<p><strong>练习26.6：重构悲剧架构</strong>
将《哈姆雷特》重构为微服务架构，每个角色是独立服务，通过API通信。这会如何改变故事的结局？</p>
<p><em>提示：考虑服务隔离、熔断机制、服务降级</em></p>
<details>
<summary>参考答案</summary>
<p>微服务架构重构：</p>
<div class="codehilite"><pre><span></span><code><span class="nt">services</span><span class="p">:</span>
<span class="w">  </span><span class="nt">hamlet-service</span><span class="p">:</span>
<span class="w">    </span><span class="nt">endpoints</span><span class="p">:</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/investigate</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/contemplate</span><span class="w">  </span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/act</span>
<span class="w">    </span><span class="nt">dependencies</span><span class="p">:</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">ghost-service</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">conscience-service</span>

<span class="w">  </span><span class="nt">claudius-service</span><span class="p">:</span>
<span class="w">    </span><span class="nt">endpoints</span><span class="p">:</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/rule</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/plot</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/defend</span>
<span class="w">    </span><span class="nt">circuit-breaker</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">enabled</span>

<span class="w">  </span><span class="nt">polonius-service</span><span class="p">:</span>
<span class="w">    </span><span class="nt">endpoints</span><span class="p">:</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/spy</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/advise</span>
<span class="w">    </span><span class="nt">health-check</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">enabled</span>
<span class="w">    </span><span class="nt">auto-restart</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>

<span class="w">  </span><span class="nt">ophelia-service</span><span class="p">:</span>
<span class="w">    </span><span class="nt">endpoints</span><span class="p">:</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/love</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/obey</span>
<span class="w">    </span><span class="nt">fallback</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">madness-mode</span>

<span class="w">  </span><span class="nt">api-gateway</span><span class="p">:</span>
<span class="w">    </span><span class="nt">rate-limiting</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
<span class="w">    </span><span class="nt">authentication</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">required</span>
<span class="w">    </span><span class="nt">logging</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">verbose</span>
</code></pre></div>

<p>架构优势：</p>
<ol>
<li><strong>服务隔离</strong>：一个服务崩溃不影响其他</li>
<li><strong>熔断机制</strong>：Polonius被杀后，自动熔断相关调用</li>
<li><strong>服务降级</strong>：Ophelia疯狂后降级为只读服务</li>
<li><strong>监控告警</strong>：异常行为触发告警</li>
<li><strong>回滚能力</strong>：可以回滚危险操作</li>
</ol>
<p>可能的新结局：</p>
<ul>
<li>系统检测到异常，自动隔离问题服务</li>
<li>通过API限流，避免级联失败</li>
<li>日志分析提前发现阴谋</li>
<li>整体系统保持稳定，只有个别服务下线</li>
</ul>
</details>
<p><strong>练习26.7：性能优化分析</strong>
分析《哈姆雷特》中的"性能瓶颈"，提出三种优化方案来加速剧情推进，同时保持悲剧张力。</p>
<p><em>提示：考虑缓存、并行处理、预计算等技术</em></p>
<details>
<summary>参考答案</summary>
<p>性能瓶颈及优化方案：</p>
<p><strong>瓶颈1：哈姆雷特的决策延迟</strong></p>
<ul>
<li>原因：每次都重新思考全部问题</li>
<li>优化：决策缓存</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="nd">@cache</span>
<span class="k">def</span> <span class="nf">shouldRevenge</span><span class="p">(</span><span class="n">evidence</span><span class="p">,</span> <span class="n">moral_state</span><span class="p">):</span>
    <span class="c1"># 相同输入直接返回缓存结果</span>
    <span class="k">return</span> <span class="n">decision</span>
</code></pre></div>

<p><strong>瓶颈2：信息传递的串行化</strong></p>
<ul>
<li>原因：通过单一渠道（主要是Polonius）传递</li>
<li>优化：并行通信</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">gatherIntelligence</span><span class="p">():</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">spy_on_hamlet</span><span class="p">(),</span>
        <span class="n">observe_ophelia</span><span class="p">(),</span>
        <span class="n">monitor_court</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">merge_intelligence</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</code></pre></div>

<p><strong>瓶颈3：验证真相的单点测试</strong></p>
<ul>
<li>原因：只依赖戏中戏一个测试</li>
<li>优化：预计算多个验证方案</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">precompute_tests</span><span class="p">():</span>
    <span class="n">tests</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">theatrical_test</span><span class="p">(),</span>
        <span class="n">confession_trap</span><span class="p">(),</span>
        <span class="n">witness_interview</span><span class="p">(),</span>
        <span class="n">document_search</span><span class="p">()</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">first_successful</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
</code></pre></div>

<p>保持张力的关键：</p>
<ol>
<li>优化执行速度，但保留决策困难</li>
<li>加快信息流动，但保持误解可能</li>
<li>并行推进多条线索，增加紧张感</li>
</ol>
</details>
<h2 id="_5">常见陷阱与错误</h2>
<h3 id="1">1. 过度简化悲剧机制</h3>
<p><strong>错误</strong>：认为悲剧只需要"坏事发生"
<strong>正确</strong>：悲剧需要必然性、因果链和系统性失败</p>
<h3 id="2">2. 忽视延宕的叙事价值</h3>
<p><strong>错误</strong>：认为哈姆雷特的犹豫是"拖剧情"
<strong>正确</strong>：延宕创造了思想深度和道德复杂性</p>
<h3 id="3">3. 孤立看待角色行动</h3>
<p><strong>错误</strong>：单独分析每个角色的动机和行动
<strong>正确</strong>：将所有角色视为相互影响的系统组件</p>
<h3 id="4">4. 线性理解因果关系</h3>
<p><strong>错误</strong>：A导致B，B导致C的简单因果链
<strong>正确</strong>：多重因果的网状结构和反馈循环</p>
<h3 id="5">5. 忽视小事件的蝴蝶效应</h3>
<p><strong>错误</strong>：只关注主要冲突和重大事件
<strong>正确</strong>：识别小错误如何触发级联崩溃</p>
<h2 id="_6">最佳实践检查清单</h2>
<h3 id="_7">悲剧系统设计检查项</h3>
<h4 id="_8">结构完整性</h4>
<ul>
<li>[ ] 是否建立了清晰的"死锁"条件？</li>
<li>[ ] 角色间的依赖关系是否会导致循环等待？</li>
<li>[ ] 是否设计了无法兼容的多重目标？</li>
</ul>
<h4 id="_9">递归陷阱设置</h4>
<ul>
<li>[ ] 复仇或冲突是否有明确的终止条件？</li>
<li>[ ] 是否故意移除了终止条件以创造悲剧？</li>
<li>[ ] 递归深度是否足以造成"栈溢出"？</li>
</ul>
<h4 id="_10">状态管理</h4>
<ul>
<li>[ ] 角色的心理状态转换是否不可逆？</li>
<li>[ ] 是否有伪装状态增加系统复杂度？</li>
<li>[ ] 状态转换的触发条件是否明确？</li>
</ul>
<h4 id="_11">测试悲剧设计</h4>
<ul>
<li>[ ] 角色的"测试"行为是否会改变系统状态？</li>
<li>[ ] 测试是否会暴露测试者的意图？</li>
<li>[ ] 是否设计了测试的意外后果？</li>
</ul>
<h4 id="_12">级联失败规划</h4>
<ul>
<li>[ ] 是否识别了触发级联的关键事件？</li>
<li>[ ] 错误传播路径是否清晰？</li>
<li>[ ] 是否移除了所有"断路器"和安全机制？</li>
</ul>
<h4 id="_13">系统脆弱性评估</h4>
<ul>
<li>[ ] 是否存在单点故障？</li>
<li>[ ] 组件间耦合是否过紧？</li>
<li>[ ] 是否缺乏错误恢复机制？</li>
</ul>
<h4 id="_14">时机控制</h4>
<ul>
<li>[ ] 延宕是否在积累势能？</li>
<li>[ ] 爆发点的时机是否精确？</li>
<li>[ ] 多条线索的汇合是否自然？</li>
</ul>
<h4 id="_15">道德复杂度</h4>
<ul>
<li>[ ] 是否避免了简单的善恶对立？</li>
<li>[ ] 每个角色的行动是否都有合理动机？</li>
<li>[ ] 观众是否会产生道德困境？</li>
</ul>
<h4 id="_16">情感共鸣</h4>
<ul>
<li>[ ] 悲剧是否激发恐惧与怜悯？</li>
<li>[ ] 是否达到了净化（catharsis）效果？</li>
<li>[ ] 结局是否既必然又令人惋惜？</li>
</ul>
<h4 id="_17">主题升华</h4>
<ul>
<li>[ ] 个人悲剧是否反映了普遍真理？</li>
<li>[ ] 是否探讨了永恒的人性问题？</li>
<li>[ ] 悲剧是否具有超越时代的意义？</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="./chapter25.html" class="nav-link prev">← 第25章：成长故事的升级系统——从零到英雄的经验值累积</a><a href="./chapter27.html" class="nav-link next">第27章：案例解析：《西游记》的升级系统与团队副本设计 →</a></nav>
        </main>
    </div>
</body>
</html>